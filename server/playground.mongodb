// const mongoose = require("mongoose");

// MongoDB Playground
// To disable this template go to Settings | MongoDB | Use Default Template For Playground.
// Make sure you are connected to enable completions and to be able to run a playground.
// Use Ctrl+Space inside a snippet or a string literal to trigger completions.

// Select the database to use.
use('test');


/*res = db.infos.findOne({played_at: { $gte: new Date("2022-12-30T19:57:42.087Z")}})
print(JSON.stringify(res))*/
//const user = { _id: res.owner };

const start = new Date('2023-01-10T15:36:12');
const end = new Date('2023-01-11T15:36:12');

const getGroupByDateProjection = () => ({
  year: {
    $year: {
      date: '$played_at',
      timezone: 'Europe/Paris',
    },
  },
  month: {
    $month: {
      date: '$played_at',
      timezone: 'Europe/Paris',
    },
  },
  day: {
    $dayOfMonth: {
      date: '$played_at',
      timezone: 'Europe/Paris',
    },
  },
  week: {
    $week: {
      date: '$played_at',
      timezone: 'Europe/Paris',
    },
  },
  hour: {
    $hour: {
      date: '$played_at',
      timezone: 'Europe/Paris',
    },
  },
});

const lightTrackLookupPipeline = (idField = 'id') => ({
  let: { id: `$${idField}` },
  pipeline: [
    { $match: { $expr: { $eq: ['$id', '$$id'] } } },
    {
      $project: {
        _id: 1,
        id: 1,
        name: 1,
        artists: 1,
        album: 1,
        images: 1,
        duration_ms: 1,
      },
    },
  ],
  from: 'tracks',
  as: 'track',
});

const lightArtistLookupPipeline = (
  idField = 'track.artists',
  isFieldArray = true,
) => ({
  let: { id: isFieldArray ? { $first: `$${idField}` } : `$${idField}` },
  pipeline: [
    { $match: { $expr: { $eq: ['$id', '$$id'] } } },
    { $project: { _id: 1, id: 1, name: 1, images: 1, genres: 1 } },
  ],
  from: 'artists',
  as: 'artist',
});

// Build an aggregation to view total sales for each product in 2014.
const aggregation = [
    { $match: { played_at: { $gt: start, $lt: end } } },
    { $addFields: { hour: getGroupByDateProjection().hour, amountListened: 1 } },
    { $lookup: lightTrackLookupPipeline('id') },
      { $unwind: '$track' },
    { $addFields: { amountArtists: { $size: '$track.artists' } } },
    { $match: { amountArtists: { $ne: 0 } } },
    { $set: { amountListened: { $divide: ['$amountListened', '$amountArtists'] } } },
    { $unwind: '$track.artists' },
    { $lookup: lightArtistLookupPipeline('track.artists', false) },
      { $unwind: '$artist' },
    { 
      $project: { 
        _id: 1,
        hour: 1,
        track: { id: 1, duration_ms: 1, name: 1 },
        amountListened: 1,
        amountArtists: 1,
        artist: { id: 1, genres: 1 },
        genres: 1,
        artistId: 1,
      }
    },
    { $addFields: { amountGenres: { $size: '$artist.genres' } } },
    { $match: { amountGenres: { $ne: 0 } } },
    { $set: { amountListened: { $divide: ['$amountListened', '$amountGenres'] } } },
    { $unwind: '$artist.genres' },
    {
      $group: {
        _id: { genre: '$artist.genres', hour: '$hour'},
        hour: { $first: '$hour' },
        // tracks: { $addToSet: '$track' },
        genre: { $first: '$artist.genres' },
        amountListened: { $sum: '$amountListened' },
        artistIds: { $addToSet: '$artist.id' },
      }
    },
    { $sort: { amountListened: -1 }},
    {
      $group: {
        _id: '$hour',
        genres: { $push: {
          genre: '$genre',
          // tracks: '$tracks',
          amountListened: '$amountListened',
          artistIds: '$artistIds',
        }},
        total: { $sum: '$amountListened' }
      }
    },
    { $sort: { _id: 1 }},
  ];

// Run the aggregation and open a cursor to the results.
// Use toArray() to exhaust the cursor to return the whole result set.
// You can use hasNext()/next() to iterate through the cursor page by page.

db.infos.aggregate(aggregation)
//db.infos.aggregate(aggregation.filter((_,i) => i < 16))
// dann genres dazu und neu ($unwind + ) grupieren
